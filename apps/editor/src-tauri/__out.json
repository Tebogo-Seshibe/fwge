[{"name":"Project","code":"import { Game } from \"/@fs/../node_modules/@fwge/core/lib/index\";\nimport { EditorScene, Scene1 } from \"./scenes\";\nclass Project extends Game {\n    constructor() {\n        super({\n            scenes: [\n                EditorScene,\n                Scene1,\n            ],\n            startupScene: 0,\n            height: 1080,\n            width: 1920,\n        });\n    }\n}\n"},{"name":"CubeMesh","code":"import { StaticMesh } from \"/@fs/../node_modules/@fwge/core/lib/index\";\nclass CubeMesh extends StaticMesh {\n    constructor() {\n        super({\n            name: 'Cube Mesh',\n            position: [\n                [-0.5, 0.5, 0.5],\n                [-0.5, -0.5, 0.5],\n                [0.5, -0.5, 0.5],\n                [0.5, 0.5, 0.5],\n                [0.5, 0.5, 0.5],\n                [0.5, -0.5, 0.5],\n                [0.5, -0.5, -0.5],\n                [0.5, 0.5, -0.5],\n                [0.5, 0.5, -0.5],\n                [0.5, -0.5, -0.5],\n                [-0.5, -0.5, -0.5],\n                [-0.5, 0.5, -0.5],\n                [-0.5, 0.5, -0.5],\n                [-0.5, -0.5, -0.5],\n                [-0.5, -0.5, 0.5],\n                [-0.5, 0.5, 0.5],\n                [-0.5, 0.5, -0.5],\n                [-0.5, 0.5, 0.5],\n                [0.5, 0.5, 0.5],\n                [0.5, 0.5, -0.5],\n                [-0.5, -0.5, 0.5],\n                [-0.5, -0.5, -0.5],\n                [0.5, -0.5, -0.5],\n                [0.5, -0.5, 0.5],\n            ],\n            normal: [\n                [0.0, 0.0, 1.0],\n                [0.0, 0.0, 1.0],\n                [0.0, 0.0, 1.0],\n                [0.0, 0.0, 1.0],\n                [1.0, 0.0, 0.0],\n                [1.0, 0.0, 0.0],\n                [1.0, 0.0, 0.0],\n                [1.0, 0.0, 0.0],\n                [0.0, 0.0, -1.0],\n                [0.0, 0.0, -1.0],\n                [0.0, 0.0, -1.0],\n                [0.0, 0.0, -1.0],\n                [-1.0, 0.0, 0.0],\n                [-1.0, 0.0, 0.0],\n                [-1.0, 0.0, 0.0],\n                [-1.0, 0.0, 0.0],\n                [0.0, 1.0, 0.0],\n                [0.0, 1.0, 0.0],\n                [0.0, 1.0, 0.0],\n                [0.0, 1.0, 0.0],\n                [0.0, -1.0, 0.0],\n                [0.0, -1.0, 0.0],\n                [0.0, -1.0, 0.0],\n                [0.0, -1.0, 0.0],\n            ],\n            colour: [\n                [1.0, 1.0, 1.0, 1.0],\n                [1.0, 1.0, 1.0, 1.0],\n                [1.0, 1.0, 1.0, 1.0],\n                [1.0, 1.0, 1.0, 1.0],\n                [1.0, 1.0, 1.0, 1.0],\n                [1.0, 1.0, 1.0, 1.0],\n                [1.0, 1.0, 1.0, 1.0],\n                [1.0, 1.0, 1.0, 1.0],\n                [1.0, 1.0, 1.0, 1.0],\n                [1.0, 1.0, 1.0, 1.0],\n                [1.0, 1.0, 1.0, 1.0],\n                [1.0, 1.0, 1.0, 1.0],\n                [1.0, 1.0, 1.0, 1.0],\n                [1.0, 1.0, 1.0, 1.0],\n                [1.0, 1.0, 1.0, 1.0],\n                [1.0, 1.0, 1.0, 1.0],\n                [1.0, 1.0, 1.0, 1.0],\n                [1.0, 1.0, 1.0, 1.0],\n                [1.0, 1.0, 1.0, 1.0],\n                [1.0, 1.0, 1.0, 1.0],\n                [1.0, 1.0, 1.0, 1.0],\n                [1.0, 1.0, 1.0, 1.0],\n                [1.0, 1.0, 1.0, 1.0],\n                [1.0, 1.0, 1.0, 1.0],\n            ],\n            uv: [\n                [0.0, 1.0],\n                [0.0, 0.0],\n                [1.0, 0.0],\n                [1.0, 1.0],\n                [0.0, 1.0],\n                [0.0, 0.0],\n                [1.0, 0.0],\n                [1.0, 1.0],\n                [0.0, 1.0],\n                [0.0, 0.0],\n                [1.0, 0.0],\n                [1.0, 1.0],\n                [0.0, 1.0],\n                [0.0, 0.0],\n                [1.0, 0.0],\n                [1.0, 1.0],\n                [0.0, 1.0],\n                [0.0, 0.0],\n                [1.0, 0.0],\n                [1.0, 1.0],\n                [0.0, 1.0],\n                [0.0, 0.0],\n                [1.0, 0.0],\n                [1.0, 1.0],\n            ],\n            index: [\n                0, 1, 2, 0, 2, 3,\n                4, 5, 6, 4, 6, 7,\n                8, 9, 10, 8, 10, 11,\n                12, 13, 14, 12, 14, 15,\n                16, 17, 18, 16, 18, 19,\n                20, 21, 22, 20, 22, 23,\n            ]\n        });\n    }\n}\n"},{"name":"CubeShader","code":"import { Shader } from \"/@fs/../node_modules/@fwge/core/lib/index\";\nclass CubeShader extends Shader {\n    constructor() {\n        super(`#version 300 es\r\n            #pragma vscode_glsllint_stage: vert\r\n\r\n            //#include its_a_potato\r\n\r\n            layout (std140) uniform;\r\n            precision highp float;\r\n\r\n            layout(location = 0) in vec3 A_Position;\r\n            layout(location = 1) in vec3 A_Normal;\r\n            layout(location = 2) in vec2 A_UV;\r\n            layout(location = 3) in vec4 A_Colour;\r\n\r\n            struct Vertex\r\n            {\r\n                vec3 Position;\r\n                vec3 Normal;\r\n                vec2 UV;\r\n                vec3 Colour;\r\n            };\r\n            out Vertex V_Vertex;\r\n\r\n            uniform Transform\r\n            {\r\n                mat4 Model;\r\n                mat3 Normal;\r\n            } transform;\r\n\r\n            uniform Camera\r\n            {\r\n                mat4 View;\r\n                mat4 Projection;\r\n                vec3 Position;\r\n            } camera;\r\n\r\n            void main(void)\r\n            {\r\n                V_Vertex.Position = (transform.Model * vec4(A_Position, 1.0)).xyz;\r\n                V_Vertex.Normal = normalize(transform.Normal * A_Normal);\r\n                V_Vertex.UV = A_UV;\r\n                V_Vertex.Colour = A_Colour.rgb;\r\n                \r\n                gl_Position = camera.Projection * camera.View * vec4(V_Vertex.Position, 1.0);\r\n            }`, `#version 300 es\r\n            #pragma vscode_glsllint_stage: frag\r\n\r\n            precision highp float;\r\n            precision highp sampler2D;\r\n\r\n            layout (std140) uniform;\r\n            layout(location = 0) out vec3 O_Position;\r\n            layout(location = 1) out vec3 O_Normal;\r\n            layout(location = 2) out vec4 O_Albedo_Alpha;\r\n\r\n            struct Vertex\r\n            {\r\n                vec3 Position;\r\n                vec3 Normal;\r\n                vec2 UV;\r\n                vec3 Colour;\r\n            };\r\n            in Vertex V_Vertex;\r\n\r\n            struct Sampler\r\n            {\r\n                sampler2D Image;\r\n                sampler2D Bump;\r\n            };\r\n            uniform Sampler U_Sampler;\r\n\r\n            uniform BasicLitMaterial\r\n            {\r\n                vec3 Colour;\r\n                float Shininess;\r\n                float Alpha;\r\n\r\n                vec3 Ambient;\r\n                vec3 Diffuse;\r\n                vec3 Specular;\r\n\r\n                bool HasImageMap;\r\n                bool HasBumpMap;\r\n                bool ReceiveShadows;\r\n            } basicLitMaterial;\r\n\r\n            void main(void)\r\n            {\r\n                vec4 tex = texture(U_Sampler.Image, V_Vertex.UV);\r\n                vec3 albedo = basicLitMaterial.Colour * tex.rgb * V_Vertex.Colour;\r\n                float alpha = basicLitMaterial.Alpha * tex.a;\r\n\r\n                O_Position = V_Vertex.Position;\r\n                O_Normal = normalize(V_Vertex.Normal * texture(U_Sampler.Bump, V_Vertex.UV).xyz);\r\n                O_Albedo_Alpha = vec4(albedo, alpha);\r\n            }`);\n    }\n}\nexport class FinalPassShader extends Shader {\n    constructor() {\n        super(`#version 300 es\r\n            #pragma vscode_glsllint_stage: vert\r\n\r\n            layout(location = 0) in vec2 A_Position;\r\n            out vec2 V_UV;\r\n\r\n            void main(void)\r\n            {\r\n                V_UV = A_Position * 0.5 + 0.5;\r\n                gl_Position = vec4(A_Position, 0.0, 1.0);\r\n            }\r\n            `, `#version 300 es\r\n            #pragma vscode_glsllint_stage: frag\r\n\r\n            precision highp float;\r\n            layout (std140) uniform;\r\n\r\n            in vec2 V_UV;\r\n            layout(location = 0) out vec4 O_FragColour;\r\n\r\n            uniform Camera\r\n            {\r\n                mat4 View;\r\n                mat4 Projection;\r\n                vec3 Position;\r\n            } camera;\r\n\r\n            struct Fragment\r\n            {\r\n                vec3 Position;\r\n                vec3 Normal;\r\n                vec3 Diffuse;\r\n                float Alpha;\r\n                float Depth;\r\n            } fragment;\r\n            uniform sampler2D U_Position;\r\n            uniform sampler2D U_Normal;\r\n            uniform sampler2D U_Albedo_Alpha;\r\n            uniform sampler2D U_Depth;\r\n            uniform sampler2D U_Dir_Tex;\r\n\r\n            // Area Lighting ---------------------------------------\r\n            struct AreaLight\r\n            {\r\n                vec3 Colour;\r\n                float Intensity;\r\n            };\r\n            uniform AreaLight[1] U_AreaLight;\r\n\r\n            vec3 CalcAreaLight(AreaLight light)\r\n            {\r\n                return light.Colour * light.Intensity;\r\n            }\r\n            // Area Lighting ---------------------------------------\r\n\r\n            // Directional Lighting --------------------------------\r\n            struct DirectionalLight\r\n            {\r\n                vec3 Colour;\r\n                float Intensity;\r\n\r\n                vec3 Direction;\r\n                bool CastShadows;\r\n\r\n                float TexelSize;\r\n                float TexelCount;\r\n                float Bias;\r\n                float PCFLevel;\r\n\r\n                mat4 ProjectionMatrix;\r\n                mat4 ViewMatrix;\r\n            };\r\n            uniform DirectionalLight[1] U_DirectionalLight;\r\n\r\n            float BasicShadowWeightDirectional(DirectionalLight dir, float diffuseDot, float specularDot, sampler2D shadowSampler, mat4 shadowMatrix)\r\n            {\r\n                vec4 shadowPosition = shadowMatrix * vec4(fragment.Position, 1.0);\r\n                vec3 lightPosition = (shadowPosition.xyz / shadowPosition.w) * 0.5 + 0.5;\r\n                vec2 fragUV = lightPosition.xy;\r\n                float shadowDepth = texture(shadowSampler, fragUV).r;\r\n\r\n                return 1.0;\r\n            }\r\n\r\n            float ShadowWeightDirectional(DirectionalLight dir, float diffuseDot, float specularDot, sampler2D shadowSampler, mat4 shadowMatrix)\r\n            {\r\n                vec4 shadowPosition = shadowMatrix * vec4(fragment.Position, 1.0);\r\n                vec3 lightPosition = shadowPosition.xyz * 0.5 + 0.5;\r\n                \r\n                float bias = max(dir.Bias * (1.0 - diffuseDot), 0.0005);\r\n                vec2 fragUV = lightPosition.xy;\r\n                float fragmentDepth = lightPosition.z;\r\n\r\n                if (fragmentDepth > 1.0)\r\n                {\r\n                    fragmentDepth = 1.0;\r\n                }\r\n\r\n                float total = 0.0;\r\n                for (float x = -dir.PCFLevel; x <= dir.PCFLevel; ++x)\r\n                {\r\n                    for (float y = -dir.PCFLevel; y <= dir.PCFLevel; ++y)\r\n                    {\r\n                        vec2 offset = vec2(x, y) * dir.TexelSize;\r\n                        vec2 uv = fragUV + offset;\r\n                        if (uv.x < 0.0 || uv.y < 0.0 || uv.x > 1.0 || uv.y > 1.0)\r\n                        {\r\n                            continue;\r\n                        }\r\n\r\n                        float shadowDepth = texture(shadowSampler, fragUV).r + bias;\r\n                        if (shadowDepth < fragmentDepth)\r\n                        {\r\n                            total += 1.0;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // return 1.0;\r\n                return total / dir.TexelCount;\r\n            }\r\n\r\n            vec3 CalcDirectionalLight(DirectionalLight light)\r\n            {\r\n                mat4 shadowMatrix = light.ProjectionMatrix * light.ViewMatrix;\r\n\r\n                float diffuseInfluence = max(dot(fragment.Normal, light.Direction), 0.0);\r\n                vec3 diffuse = light.Colour * diffuseInfluence * light.Intensity;\r\n\r\n                // vec4 viewPosition = inverse(camera.Projection) * vec4(fragment.Position, 1.0);\r\n                // vec3 halfway = normalize(light.Direction - viewPosition.xyz);\r\n                // float specularInfluence = pow(max(dot(fragment.Normal, halfway), 0.0), 64.0);\r\n                // vec3 specular = light.Colour * specularInfluence * light.Intensity;\r\n\r\n                float shadow = ShadowWeightDirectional(light, diffuseInfluence, 1.0, U_Dir_Tex, shadowMatrix);\r\n\r\n                return (diffuse) * (1.0 - shadow);\r\n            }\r\n            // Directional Lighting --------------------------------\r\n\r\n\r\n            void main(void)\r\n            {\r\n                fragment = Fragment(\r\n                    texture(U_Position, V_UV).rgb,\r\n                    texture(U_Normal, V_UV).rgb,\r\n                    texture(U_Albedo_Alpha, V_UV).rgb,\r\n                    texture(U_Albedo_Alpha, V_UV).a,\r\n                    texture(U_Depth, V_UV).r\r\n                );\r\n\r\n                vec3 light = vec3(0.0);\r\n                vec3 area = vec3(0.0);\r\n                vec3 dir = vec3(0.0);\r\n\r\n                for (int i = 0; i < U_AreaLight.length(); ++i)\r\n                {\r\n                    area += CalcAreaLight(U_AreaLight[i]);\r\n                }\r\n                    \r\n                for (int i = 0; i < U_DirectionalLight.length(); ++i)\r\n                {\r\n                    dir += CalcDirectionalLight(U_DirectionalLight[i]);\r\n                }\r\n\r\n                light = area + dir;\r\n                \r\n                // O_FragColour = vec4(fragment.Diffuse, fragment.Alpha);\r\n                // O_FragColour = vec4(light, fragment.Alpha);\r\n                // O_FragColour = vec4(vec3(texture(U_Dir_Tex, V_UV).r), fragment.Alpha);\r\n                O_FragColour = vec4(fragment.Diffuse * light, fragment.Alpha);\r\n            }`, 'Cube Shader');\n    }\n}\n"},{"name":"FinalPassShader","code":"import { Shader } from \"/@fs/../node_modules/@fwge/core/lib/index\";\nclass CubeShader extends Shader {\n    constructor() {\n        super(`#version 300 es\r\n            #pragma vscode_glsllint_stage: vert\r\n\r\n            //#include its_a_potato\r\n\r\n            layout (std140) uniform;\r\n            precision highp float;\r\n\r\n            layout(location = 0) in vec3 A_Position;\r\n            layout(location = 1) in vec3 A_Normal;\r\n            layout(location = 2) in vec2 A_UV;\r\n            layout(location = 3) in vec4 A_Colour;\r\n\r\n            struct Vertex\r\n            {\r\n                vec3 Position;\r\n                vec3 Normal;\r\n                vec2 UV;\r\n                vec3 Colour;\r\n            };\r\n            out Vertex V_Vertex;\r\n\r\n            uniform Transform\r\n            {\r\n                mat4 Model;\r\n                mat3 Normal;\r\n            } transform;\r\n\r\n            uniform Camera\r\n            {\r\n                mat4 View;\r\n                mat4 Projection;\r\n                vec3 Position;\r\n            } camera;\r\n\r\n            void main(void)\r\n            {\r\n                V_Vertex.Position = (transform.Model * vec4(A_Position, 1.0)).xyz;\r\n                V_Vertex.Normal = normalize(transform.Normal * A_Normal);\r\n                V_Vertex.UV = A_UV;\r\n                V_Vertex.Colour = A_Colour.rgb;\r\n                \r\n                gl_Position = camera.Projection * camera.View * vec4(V_Vertex.Position, 1.0);\r\n            }`, `#version 300 es\r\n            #pragma vscode_glsllint_stage: frag\r\n\r\n            precision highp float;\r\n            precision highp sampler2D;\r\n\r\n            layout (std140) uniform;\r\n            layout(location = 0) out vec3 O_Position;\r\n            layout(location = 1) out vec3 O_Normal;\r\n            layout(location = 2) out vec4 O_Albedo_Alpha;\r\n\r\n            struct Vertex\r\n            {\r\n                vec3 Position;\r\n                vec3 Normal;\r\n                vec2 UV;\r\n                vec3 Colour;\r\n            };\r\n            in Vertex V_Vertex;\r\n\r\n            struct Sampler\r\n            {\r\n                sampler2D Image;\r\n                sampler2D Bump;\r\n            };\r\n            uniform Sampler U_Sampler;\r\n\r\n            uniform BasicLitMaterial\r\n            {\r\n                vec3 Colour;\r\n                float Shininess;\r\n                float Alpha;\r\n\r\n                vec3 Ambient;\r\n                vec3 Diffuse;\r\n                vec3 Specular;\r\n\r\n                bool HasImageMap;\r\n                bool HasBumpMap;\r\n                bool ReceiveShadows;\r\n            } basicLitMaterial;\r\n\r\n            void main(void)\r\n            {\r\n                vec4 tex = texture(U_Sampler.Image, V_Vertex.UV);\r\n                vec3 albedo = basicLitMaterial.Colour * tex.rgb * V_Vertex.Colour;\r\n                float alpha = basicLitMaterial.Alpha * tex.a;\r\n\r\n                O_Position = V_Vertex.Position;\r\n                O_Normal = normalize(V_Vertex.Normal * texture(U_Sampler.Bump, V_Vertex.UV).xyz);\r\n                O_Albedo_Alpha = vec4(albedo, alpha);\r\n            }`);\n    }\n}\nexport class FinalPassShader extends Shader {\n    constructor() {\n        super(`#version 300 es\r\n            #pragma vscode_glsllint_stage: vert\r\n\r\n            layout(location = 0) in vec2 A_Position;\r\n            out vec2 V_UV;\r\n\r\n            void main(void)\r\n            {\r\n                V_UV = A_Position * 0.5 + 0.5;\r\n                gl_Position = vec4(A_Position, 0.0, 1.0);\r\n            }\r\n            `, `#version 300 es\r\n            #pragma vscode_glsllint_stage: frag\r\n\r\n            precision highp float;\r\n            layout (std140) uniform;\r\n\r\n            in vec2 V_UV;\r\n            layout(location = 0) out vec4 O_FragColour;\r\n\r\n            uniform Camera\r\n            {\r\n                mat4 View;\r\n                mat4 Projection;\r\n                vec3 Position;\r\n            } camera;\r\n\r\n            struct Fragment\r\n            {\r\n                vec3 Position;\r\n                vec3 Normal;\r\n                vec3 Diffuse;\r\n                float Alpha;\r\n                float Depth;\r\n            } fragment;\r\n            uniform sampler2D U_Position;\r\n            uniform sampler2D U_Normal;\r\n            uniform sampler2D U_Albedo_Alpha;\r\n            uniform sampler2D U_Depth;\r\n            uniform sampler2D U_Dir_Tex;\r\n\r\n            // Area Lighting ---------------------------------------\r\n            struct AreaLight\r\n            {\r\n                vec3 Colour;\r\n                float Intensity;\r\n            };\r\n            uniform AreaLight[1] U_AreaLight;\r\n\r\n            vec3 CalcAreaLight(AreaLight light)\r\n            {\r\n                return light.Colour * light.Intensity;\r\n            }\r\n            // Area Lighting ---------------------------------------\r\n\r\n            // Directional Lighting --------------------------------\r\n            struct DirectionalLight\r\n            {\r\n                vec3 Colour;\r\n                float Intensity;\r\n\r\n                vec3 Direction;\r\n                bool CastShadows;\r\n\r\n                float TexelSize;\r\n                float TexelCount;\r\n                float Bias;\r\n                float PCFLevel;\r\n\r\n                mat4 ProjectionMatrix;\r\n                mat4 ViewMatrix;\r\n            };\r\n            uniform DirectionalLight[1] U_DirectionalLight;\r\n\r\n            float BasicShadowWeightDirectional(DirectionalLight dir, float diffuseDot, float specularDot, sampler2D shadowSampler, mat4 shadowMatrix)\r\n            {\r\n                vec4 shadowPosition = shadowMatrix * vec4(fragment.Position, 1.0);\r\n                vec3 lightPosition = (shadowPosition.xyz / shadowPosition.w) * 0.5 + 0.5;\r\n                vec2 fragUV = lightPosition.xy;\r\n                float shadowDepth = texture(shadowSampler, fragUV).r;\r\n\r\n                return 1.0;\r\n            }\r\n\r\n            float ShadowWeightDirectional(DirectionalLight dir, float diffuseDot, float specularDot, sampler2D shadowSampler, mat4 shadowMatrix)\r\n            {\r\n                vec4 shadowPosition = shadowMatrix * vec4(fragment.Position, 1.0);\r\n                vec3 lightPosition = shadowPosition.xyz * 0.5 + 0.5;\r\n                \r\n                float bias = max(dir.Bias * (1.0 - diffuseDot), 0.0005);\r\n                vec2 fragUV = lightPosition.xy;\r\n                float fragmentDepth = lightPosition.z;\r\n\r\n                if (fragmentDepth > 1.0)\r\n                {\r\n                    fragmentDepth = 1.0;\r\n                }\r\n\r\n                float total = 0.0;\r\n                for (float x = -dir.PCFLevel; x <= dir.PCFLevel; ++x)\r\n                {\r\n                    for (float y = -dir.PCFLevel; y <= dir.PCFLevel; ++y)\r\n                    {\r\n                        vec2 offset = vec2(x, y) * dir.TexelSize;\r\n                        vec2 uv = fragUV + offset;\r\n                        if (uv.x < 0.0 || uv.y < 0.0 || uv.x > 1.0 || uv.y > 1.0)\r\n                        {\r\n                            continue;\r\n                        }\r\n\r\n                        float shadowDepth = texture(shadowSampler, fragUV).r + bias;\r\n                        if (shadowDepth < fragmentDepth)\r\n                        {\r\n                            total += 1.0;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // return 1.0;\r\n                return total / dir.TexelCount;\r\n            }\r\n\r\n            vec3 CalcDirectionalLight(DirectionalLight light)\r\n            {\r\n                mat4 shadowMatrix = light.ProjectionMatrix * light.ViewMatrix;\r\n\r\n                float diffuseInfluence = max(dot(fragment.Normal, light.Direction), 0.0);\r\n                vec3 diffuse = light.Colour * diffuseInfluence * light.Intensity;\r\n\r\n                // vec4 viewPosition = inverse(camera.Projection) * vec4(fragment.Position, 1.0);\r\n                // vec3 halfway = normalize(light.Direction - viewPosition.xyz);\r\n                // float specularInfluence = pow(max(dot(fragment.Normal, halfway), 0.0), 64.0);\r\n                // vec3 specular = light.Colour * specularInfluence * light.Intensity;\r\n\r\n                float shadow = ShadowWeightDirectional(light, diffuseInfluence, 1.0, U_Dir_Tex, shadowMatrix);\r\n\r\n                return (diffuse) * (1.0 - shadow);\r\n            }\r\n            // Directional Lighting --------------------------------\r\n\r\n\r\n            void main(void)\r\n            {\r\n                fragment = Fragment(\r\n                    texture(U_Position, V_UV).rgb,\r\n                    texture(U_Normal, V_UV).rgb,\r\n                    texture(U_Albedo_Alpha, V_UV).rgb,\r\n                    texture(U_Albedo_Alpha, V_UV).a,\r\n                    texture(U_Depth, V_UV).r\r\n                );\r\n\r\n                vec3 light = vec3(0.0);\r\n                vec3 area = vec3(0.0);\r\n                vec3 dir = vec3(0.0);\r\n\r\n                for (int i = 0; i < U_AreaLight.length(); ++i)\r\n                {\r\n                    area += CalcAreaLight(U_AreaLight[i]);\r\n                }\r\n                    \r\n                for (int i = 0; i < U_DirectionalLight.length(); ++i)\r\n                {\r\n                    dir += CalcDirectionalLight(U_DirectionalLight[i]);\r\n                }\r\n\r\n                light = area + dir;\r\n                \r\n                // O_FragColour = vec4(fragment.Diffuse, fragment.Alpha);\r\n                // O_FragColour = vec4(light, fragment.Alpha);\r\n                // O_FragColour = vec4(vec3(texture(U_Dir_Tex, V_UV).r), fragment.Alpha);\r\n                O_FragColour = vec4(fragment.Diffuse * light, fragment.Alpha);\r\n            }`, 'Cube Shader');\n    }\n}\n"},{"name":"GridMesh","code":"import { StaticMesh } from \"/@fs/../node_modules/@fwge/core/lib/index\";\nclass GridMesh extends StaticMesh {\n    constructor() {\n        super({\n            position: [\n                [100, 0, 0],\n                [-100, 0, 0],\n                [0, 100, 0],\n                [0, -100, 0],\n                [0, 0, 100],\n                [0, 0, -100],\n                [-10, 0, -10],\n                [-10, 0, 10],\n                [-9, 0, -10],\n                [-9, 0, 10],\n                [-8, 0, -10],\n                [-8, 0, 10],\n                [-7, 0, -10],\n                [-7, 0, 10],\n                [-6, 0, -10],\n                [-6, 0, 10],\n                [-5, 0, -10],\n                [-5, 0, 10],\n                [-4, 0, -10],\n                [-4, 0, 10],\n                [-3, 0, -10],\n                [-3, 0, 10],\n                [-2, 0, -10],\n                [-2, 0, 10],\n                [-1, 0, -10],\n                [-1, 0, 10],\n                [1, 0, -10],\n                [1, 0, 10],\n                [2, 0, -10],\n                [2, 0, 10],\n                [3, 0, -10],\n                [3, 0, 10],\n                [4, 0, -10],\n                [4, 0, 10],\n                [5, 0, -10],\n                [5, 0, 10],\n                [6, 0, -10],\n                [6, 0, 10],\n                [7, 0, -10],\n                [7, 0, 10],\n                [8, 0, -10],\n                [8, 0, 10],\n                [9, 0, -10],\n                [9, 0, 10],\n                [10, 0, -10],\n                [10, 0, 10],\n                [-10, 0, -10],\n                [10, 0, -10],\n                [-10, 0, -9],\n                [10, 0, -9],\n                [-10, 0, -8],\n                [10, 0, -8],\n                [-10, 0, -7],\n                [10, 0, -7],\n                [-10, 0, -6],\n                [10, 0, -6],\n                [-10, 0, -5],\n                [10, 0, -5],\n                [-10, 0, -4],\n                [10, 0, -4],\n                [-10, 0, -3],\n                [10, 0, -3],\n                [-10, 0, -2],\n                [10, 0, -2],\n                [-10, 0, -1],\n                [10, 0, -1],\n                [-10, 0, 1],\n                [10, 0, 1],\n                [-10, 0, 2],\n                [10, 0, 2],\n                [-10, 0, 3],\n                [10, 0, 3],\n                [-10, 0, 4],\n                [10, 0, 4],\n                [-10, 0, 5],\n                [10, 0, 5],\n                [-10, 0, 6],\n                [10, 0, 6],\n                [-10, 0, 7],\n                [10, 0, 7],\n                [-10, 0, 8],\n                [10, 0, 8],\n                [-10, 0, 9],\n                [10, 0, 9],\n                [-10, 0, 10],\n                [10, 0, 10],\n            ],\n            colour: [\n                [1, 0, 0, 1],\n                [1, 0, 0, 1],\n                [0, 1, 0, 1],\n                [0, 1, 0, 1],\n                [0, 0, 1, 1],\n                [0, 0, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n            ]\n        });\n    }\n}\n"},{"name":"GridShader","code":"import { Shader } from \"/@fs/../node_modules/@fwge/core/lib/index\";\nclass GridShader extends Shader {\n    constructor() {\n        super(`#version 300 es\r\n\r\n            layout (std140) uniform;\r\n            precision highp float;\r\n\r\n            layout(location = 0) in vec3 A_Position;\r\n            layout(location = 3) in vec4 A_Colour;\r\n\r\n            struct Vertex\r\n            {\r\n                vec3 Position;\r\n                vec3 Colour;\r\n            };\r\n            out Vertex V_Vertex;\r\n\r\n            uniform Object\r\n            {\r\n                mat4 ModelViewMatrix;\r\n                mat3 NormalMatrix;\r\n            } object;\r\n\r\n            uniform Camera\r\n            {\r\n                mat4 ViewMatrix;\r\n                mat4 ProjectionMatrix;\r\n            } camera;\r\n\r\n            void main(void)\r\n            {\r\n                V_Vertex.Position = (object.ModelViewMatrix * vec4(A_Position, 1.0)).xyz;    \r\n                V_Vertex.Colour = A_Colour.rgb;\r\n\r\n                gl_Position = camera.ProjectionMatrix * camera.ViewMatrix * vec4(V_Vertex.Position, 1.0);\r\n                gl_PointSize = 10.0f;\r\n            }`, `#version 300 es\r\n\r\n            precision highp float;\r\n\r\n            layout(location = 0) out vec4 O_FragColour;\r\n\r\n            struct Vertex\r\n            {\r\n                vec3 Position;\r\n                vec3 Colour;\r\n            };\r\n            in Vertex V_Vertex;\r\n\r\n            uniform BasicLitMaterial\r\n            {\r\n                vec3 Colour;\r\n                float Shininess;\r\n                float Alpha;\r\n\r\n                vec3 Ambient;\r\n                vec3 Diffuse;\r\n                vec3 Specular;\r\n\r\n                bool HasImageMap;\r\n                bool HasBumpMap;\r\n                bool ReceiveShadows;\r\n            } basicLitMaterial;\r\n\r\n            void main(void)\r\n            {\r\n                O_FragColour = vec4(V_Vertex.Colour, 1.0);\r\n            }\r\n            `);\n    }\n}\n"},{"name":"EditorTag","code":"import { Tag } from \"/@fs/../node_modules/@fwge/core/lib/index\";\nclass EditorTag extends Tag {\n    constructor() {\n        super(\"Editor\");\n    }\n}\n"},{"name":"Camera","code":"import { PerspectiveCamera, Transform } from \"/@fs/../node_modules/@fwge/core/lib/index\";\nimport { Entity } from \"/@fs/../node_modules/@fwge/ecs/lib/index\";\nclass Camera extends Entity {\n    Init() {\n        this.AddComponents(new Transform({ position: [0, 0, 10] }), new PerspectiveCamera());\n    }\n}\n"},{"name":"EditorViewer","code":"import { GL, Maths, Matrix3, Matrix4, Vector3 } from \"/@fs/../node_modules/@fwge/common/lib/index\";\nimport { PerspectiveCamera, Transform } from \"/@fs/../node_modules/@fwge/core/lib/index\";\nimport { Entity } from \"/@fs/../node_modules/@fwge/ecs/lib/index\";\nimport { ButtonState, Input, KeyState, WheelState } from \"/@fs/../node_modules/@fwge/input/lib/index\";\nimport { EditorTag } from \"../components/EditorTag\";\nclass EditorViewer extends Entity {\n    target = Vector3.Zero;\n    up = Vector3.Zero;\n    right = Vector3.Zero;\n    forward = Vector3.Zero;\n    movement = Vector3.Zero;\n    rotationMatrix = Matrix3.Zero;\n    zoomSpeed = 50;\n    rotationSpeed = 25;\n    panSpeed = 5;\n    transform;\n    cameraTransform;\n    camera;\n    locked = false;\n    constructor() {\n        super();\n        this.camera = new PerspectiveCamera({ farClipping: 100 });\n        this.cameraTransform = new Transform({ position: [0, 1, 0] });\n        this.transform = new Transform({ position: [0, 0, 10] });\n        this.AddChild(new Entity()\n            .AddComponents(new EditorTag(), this.cameraTransform, this.camera));\n        this.AddComponents(new EditorTag(), this.transform, new Input({\n            onInput: (delta, keyboard, mouse) => {\n                if (mouse.Wheel !== WheelState.CENTERED) {\n                    const scrollAmount = mouse.Wheel === WheelState.UP\n                        ? this.zoomSpeed\n                        : -this.zoomSpeed;\n                    this.Zoom(scrollAmount * delta);\n                }\n                if (mouse.Right === ButtonState.PRESSED) {\n                    if (!this.locked) {\n                        this.locked = true;\n                        GL.canvas.requestPointerLock();\n                    }\n                    this.Rotate(mouse.Offset.X * delta * this.rotationSpeed, mouse.Offset.Y * delta * this.rotationSpeed);\n                    this.Pan(delta, keyboard);\n                }\n                else {\n                    if (this.locked) {\n                        this.locked = false;\n                        document.exitPointerLock();\n                    }\n                }\n            },\n        }));\n    }\n    Rotate(deltaTheta, deltaPhi) {\n        this.cameraTransform.Rotation.X = Maths.clamp(this.cameraTransform.Rotation.X + deltaPhi, -80, 80);\n        this.transform.Rotation.Y += deltaTheta;\n    }\n    Zoom(delta) {\n        this.camera.FieldOfView -= delta;\n    }\n    Pan(delta, keyboard) {\n        const wPressed = keyboard.KeyW !== KeyState.RELEASED && keyboard.KeyW !== KeyState.UP;\n        const aPressed = keyboard.KeyA !== KeyState.RELEASED && keyboard.KeyA !== KeyState.UP;\n        const sPressed = keyboard.KeyS !== KeyState.RELEASED && keyboard.KeyS !== KeyState.UP;\n        const dPressed = keyboard.KeyD !== KeyState.RELEASED && keyboard.KeyD !== KeyState.UP;\n        const qPressed = keyboard.KeyQ !== KeyState.RELEASED && keyboard.KeyQ !== KeyState.UP;\n        const ePressed = keyboard.KeyE !== KeyState.RELEASED && keyboard.KeyE !== KeyState.UP;\n        const shiftPressed = keyboard.KeyShift !== KeyState.RELEASED && keyboard.KeyShift !== KeyState.UP;\n        const movementSpeed = this.panSpeed * (shiftPressed ? 2 : 1);\n        this.rotationMatrix.Set(Matrix4.RotationMatrix(this.transform.Rotation).Matrix3);\n        Matrix3.MultiplyVector(this.rotationMatrix, 0, 0, -1, this.forward);\n        Matrix3.MultiplyVector(this.rotationMatrix, 1, 0, 0, this.right);\n        if ((wPressed && sPressed) || (!wPressed && !sPressed)) {\n            this.forward.Set(0, 0, 0);\n        }\n        else if (!wPressed && sPressed) {\n            this.forward.Negate();\n        }\n        if ((dPressed && aPressed) || (!dPressed && !aPressed)) {\n            this.right.Set(0, 0, 0);\n        }\n        else if (!dPressed && aPressed) {\n            this.right.Negate();\n        }\n        this.up.Set(0, movementSpeed * delta, 0);\n        if ((qPressed && ePressed) || (!qPressed && !ePressed)) {\n            this.up.Set(0, 0, 0);\n        }\n        else if (!qPressed && ePressed) {\n            this.up.Negate();\n        }\n        Vector3.Add(this.forward, this.right, this.movement);\n        if (this.movement.Length !== 0) {\n            this.movement.Scale(movementSpeed * delta / this.movement.Length);\n        }\n        this.transform.Position.Add(this.movement).Add(this.up);\n    }\n}\n"},{"name":"Environment","code":"import { BasicLitMaterial, MeshRenderer, Transform } from \"/@fs/../node_modules/@fwge/core/lib/index\";\nimport { Entity } from \"/@fs/../node_modules/@fwge/ecs/lib/index\";\nimport { CubeMesh } from \"../assets/CubeMesh\";\nimport { CubeShader } from \"../assets/CubeShader\";\nimport { EditorTag } from \"../components/EditorTag\";\nclass Environment extends Entity {\n    constructor() {\n        super();\n        const ignore = new EditorTag();\n        const cubeShader = new CubeShader();\n        const cubeMeshRender = new MeshRenderer({\n            asset: new CubeMesh()\n        });\n        const floor = new Entity()\n            .AddComponents(new Transform({\n            position: [0, 0, 0],\n            rotation: [0, 0, 0],\n            scale: [2, 2, 2]\n        }), cubeMeshRender, new BasicLitMaterial({\n            shader: cubeShader,\n            alpha: 1.0,\n            projectShadows: true,\n            receiveShadows: true,\n            colour: [51 / 255, 12 / 255, 47 / 255]\n        }));\n        const cube1 = new Entity()\n            .AddComponents(ignore, new Transform({\n            position: [0, 0.5, 0],\n            rotation: [0, 0, 0],\n            scale: [1, 1, 1]\n        }), cubeMeshRender, new BasicLitMaterial({\n            shader: cubeShader,\n            alpha: 1.0,\n            projectShadows: true,\n            receiveShadows: true,\n            colour: [123 / 255, 40 / 255, 125 / 255]\n        }));\n        const cube2 = new Entity()\n            .AddComponents(ignore, new Transform({\n            position: [-2, 1, 0],\n            rotation: [0, 45, 0],\n            scale: [1, 2, 1]\n        }), cubeMeshRender, new BasicLitMaterial({\n            shader: cubeShader,\n            alpha: 1.0,\n            projectShadows: true,\n            receiveShadows: true,\n            colour: [112 / 255, 103 / 255, 207 / 255]\n        }));\n        const cube3 = new Entity()\n            .AddComponents(ignore, new Transform({\n            position: [2, 1, 0],\n            rotation: [0, 30, 0],\n            scale: [2, 2, 1]\n        }), cubeMeshRender, new BasicLitMaterial({\n            shader: cubeShader,\n            alpha: 1.0,\n            projectShadows: true,\n            receiveShadows: true,\n            colour: [183 / 255, 192 / 255, 238 / 255]\n        }));\n        const cube4 = new Entity()\n            .AddComponents(ignore, new Transform({\n            position: [0, 0.5, -2],\n            rotation: [0, 0, 0],\n            scale: [2, 1, 1]\n        }), cubeMeshRender, new BasicLitMaterial({\n            shader: cubeShader,\n            alpha: 1.0,\n            projectShadows: true,\n            receiveShadows: true,\n            colour: [203 / 255, 243 / 255, 210 / 255]\n        }));\n        const cube5 = new Entity()\n            .AddComponents(ignore, new Transform({\n            position: [0, 2.5, -2],\n            rotation: [0, 0, 0],\n            scale: [1, 1, 1]\n        }), cubeMeshRender, new BasicLitMaterial({\n            shader: cubeShader,\n            alpha: 1.0,\n            projectShadows: true,\n            receiveShadows: true,\n            colour: [203 / 255, 243 / 255, 210 / 255].map(x => x * 0.5)\n        }));\n        const cube6 = new Entity()\n            .AddComponents(ignore, new Transform({\n            position: [0, 2, -5],\n            rotation: [0, 0, 0],\n            scale: [5, 5, 1]\n        }), cubeMeshRender, new BasicLitMaterial({\n            shader: cubeShader,\n            alpha: 1.0,\n            projectShadows: true,\n            receiveShadows: true,\n            colour: [203 / 255, 243 / 255, 210 / 255].reverse() //.map(x => x * 0.25) as Colour3Array\n        }));\n        floor.Name = 'Floor';\n        cube1.Name = 'Cube 1';\n        cube2.Name = 'Cube 2';\n        cube3.Name = 'Cube 3';\n        cube4.Name = 'Cube 4';\n        cube5.Name = 'Cube 5';\n        cube6.Name = 'Cube 6';\n        this.AddChild(floor)\n            .AddChild(cube1)\n            .AddChild(cube2)\n            .AddChild(cube3)\n            .AddChild(cube6);\n        cube3.AddChild(cube4)\n            .AddChild(cube5);\n        console.log(this);\n    }\n}\n"},{"name":"GeneralAreaLight","code":"import { AreaLight } from \"/@fs/../node_modules/@fwge/core/lib/index\";\nimport { Entity } from \"/@fs/../node_modules/@fwge/ecs/lib/index\";\nclass GeneralAreaLight extends Entity {\n    constructor() {\n        super();\n        this.AddComponents(new AreaLight({\n            colour: [1, 1, 1],\n            intensity: 0.5\n        }));\n    }\n}\n"},{"name":"Grid","code":"import { BasicLitMaterial, MeshRenderer, RenderMode, Script, Transform } from \"/@fs/../node_modules/@fwge/core/lib/index\";\nimport { Entity } from \"/@fs/../node_modules/@fwge/ecs/lib/index\";\nimport { GridMesh } from \"../assets/GridMesh\";\nimport { GridShader } from \"../assets/GridShader\";\nclass Grid extends Entity {\n    constructor() {\n        super();\n        this.AddComponents(new Transform({}), new BasicLitMaterial({\n            shader: new GridShader(), // assets should be names to index from asset manager\n            colour: [1, 1, 1]\n        }), new MeshRenderer({\n            renderMode: RenderMode.EDGE,\n            asset: new GridMesh() // assets should be names to index from asset manager\n        }), new Script({}));\n    }\n    Init() {\n        console.log(this);\n    }\n}\n"},{"name":"Sun","code":"import { DirectionalLight, Transform } from \"/@fs/../node_modules/@fwge/core/lib/index\";\nimport { Entity } from \"/@fs/../node_modules/@fwge/ecs/lib/index\";\nclass Sun extends Entity {\n    constructor() {\n        super();\n        this.AddComponents(new Transform({\n            rotation: [0, 0, 0]\n        }), new DirectionalLight({\n            castShadows: true,\n            colour: [1, 1, 1],\n            intensity: 0.5\n        }));\n    }\n}\n"},{"name":"EditorScene","code":"import { DefaultWindow, Scene, ScriptSystem } from \"/@fs/../node_modules/@fwge/core/lib/index\";\nimport { InputSystem } from \"/@fs/../node_modules/@fwge/input/lib/index\";\nimport { EditorViewer } from \"../entities/EditorViewer\";\nimport { Environment } from \"../entities/Environment\";\nimport { GeneralAreaLight } from \"../entities/GeneralAreaLight\";\nimport { Sun } from \"../entities/Sun\";\nimport { ProjectRenderSystem } from \"../systems\";\nexport const EditorSceneId = 0;\nclass EditorScene extends Scene {\n    constructor(game) {\n        super(game, {\n            windows: [DefaultWindow],\n            entities: [\n            // Grid,\n            ],\n            sharedEntities: [\n                { type: GeneralAreaLight, name: 'GeneralAreaLight' },\n                { type: Sun, name: 'Sun' },\n                { type: EditorViewer, name: 'EditorViewer' },\n                { type: Environment, name: 'Environment' }\n            ],\n            systems: [\n                InputSystem,\n                ScriptSystem,\n                // EditorRenderSystem,\n                ProjectRenderSystem,\n            ],\n        });\n    }\n}\n"},{"name":"Scene1","code":"import { DefaultWindow, Scene } from \"/@fs/../node_modules/@fwge/core/lib/index\";\nimport { InputSystem } from \"/@fs/../node_modules/@fwge/input/lib/index\";\nimport { EditorViewer } from \"../entities/EditorViewer\";\nimport { Environment } from \"../entities/Environment\";\nimport { Sun } from \"../entities/Sun\";\nimport { GeneralAreaLight } from \"../entities/GeneralAreaLight\";\nclass Scene1 extends Scene {\n    constructor(game) {\n        super(game, {\n            windows: [DefaultWindow],\n            entities: [],\n            sharedEntities: [\n                { type: GeneralAreaLight, name: 'GeneralAreaLight' },\n                { type: EditorViewer, name: 'EditorViewer' },\n                { type: Sun, name: 'Sun' },\n                { type: Environment, name: 'Environment' }\n            ],\n            systems: [\n                InputSystem,\n                // ProjectRenderSystem,\n            ],\n        });\n    }\n}\n"},{"name":"EditorRenderSystem","code":"import { GL, Matrix3 } from \"/@fs/../node_modules/@fwge/common/lib/index\";\nimport { BasicLitMaterial, Camera, InstanceMesh, Material, MeshRenderer, RenderMode, Renderer, Tag, Transform } from \"/@fs/../node_modules/@fwge/core/lib/index\";\nimport { Registry, System } from \"/@fs/../node_modules/@fwge/ecs/lib/index\";\nimport { EditorTag } from \"../components/EditorTag\";\nclass EditorRenderSystem extends System {\n    cameraView;\n    renderableView;\n    Init() {\n        this.cameraView = Registry.RegisterView([Tag, Camera, Transform], (_, tag) => tag instanceof EditorTag);\n        this.renderableView = Registry.RegisterView([Tag, Material, Renderer, Transform], (_, tag) => tag instanceof EditorTag);\n    }\n    Start() {\n        return;\n    }\n    Stop() {\n        return;\n    }\n    Update() {\n        GL.enable(GL.DEPTH_TEST);\n        GL.enable(GL.CULL_FACE);\n        GL.cullFace(GL.BACK);\n        GL.depthMask(true);\n        GL.bindFramebuffer(GL.FRAMEBUFFER, null);\n        GL.viewport(0, 0, GL.drawingBufferWidth, GL.drawingBufferHeight);\n        GL.clearColor(0, 0, 0, 1);\n        GL.clear(GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT);\n        const cameraEntityId = Registry.GetView(this.cameraView)[0];\n        const cameraTransform = Registry.GetComponent(cameraEntityId, Transform);\n        const cameraCamera = Registry.GetComponent(cameraEntityId, Camera);\n        const cameraMV = cameraTransform.GlobalModelViewMatrix(cameraEntityId);\n        const cameraMVInverse = cameraMV.Inverse();\n        for (const entityId of Registry.GetView(this.renderableView)) {\n            if (!Registry.IsEntityActive(entityId)) {\n                continue;\n            }\n            const transform = Registry.GetComponent(entityId, Transform);\n            const material = Registry.GetComponent(entityId, BasicLitMaterial);\n            const renderer = Registry.GetComponent(entityId, MeshRenderer);\n            const mesh = renderer.Asset;\n            const shader = material.Shader;\n            shader.Bind();\n            shader.SetBufferDataField('Camera', 'ViewMatrix', cameraMVInverse, true);\n            shader.SetBufferDataField('Camera', 'ProjectionMatrix', cameraCamera.ProjectionMatrix, true);\n            shader.PushBufferData('Camera');\n            shader.SetBufferDataField('BasicLitMaterial', 'Colour', material.Colour);\n            shader.PushBufferData('BasicLitMaterial');\n            let renderMode;\n            let renderCount;\n            let buffer;\n            switch (renderer.RenderMode) {\n                case RenderMode.FACE:\n                    {\n                        renderMode = GL.TRIANGLES;\n                        renderCount = mesh.FaceCount;\n                        buffer = mesh.IsIndexed ? mesh.FaceBuffer : null;\n                    }\n                    break;\n                case RenderMode.EDGE:\n                    {\n                        renderMode = GL.LINES;\n                        renderCount = mesh.EdgeCount;\n                        buffer = mesh.IsIndexed ? mesh.EdgeBuffer : null;\n                    }\n                    break;\n                case RenderMode.POINT:\n                    {\n                        renderMode = GL.POINTS;\n                        renderCount = mesh.PointCount;\n                        buffer = mesh.IsIndexed ? mesh.PointBuffer : null;\n                    }\n                    break;\n            }\n            if (mesh instanceof InstanceMesh) {\n                this.drawInstanceMesh(entityId, mesh, transform, shader, buffer, renderMode, renderCount);\n            }\n            else {\n                this.drawMesh(entityId, mesh, transform, shader, buffer, renderMode, renderCount);\n            }\n            shader.UnBind();\n        }\n    }\n    drawInstanceMesh(entityId, mesh, transform, shader, buffer, renderMode, renderCount) {\n        GL.bindVertexArray(mesh.VertexArrayBuffer);\n        const modelViewMatrix = transform.GlobalModelViewMatrix(entityId);\n        shader.SetBufferDataField('Object', 'ModelViewMatrix', modelViewMatrix, true);\n        shader.SetBufferDataField('Object', 'NormalMatrix', Matrix3.Inverse(modelViewMatrix.Matrix3));\n        shader.PushBufferData('Object');\n        if (buffer) {\n            GL.bindBuffer(GL.ELEMENT_ARRAY_BUFFER, buffer);\n            GL.drawElementsInstanced(renderMode, renderCount, GL.UNSIGNED_BYTE, 0, mesh.InstanceCount);\n        }\n        else {\n            GL.drawArraysInstanced(renderMode, 0, renderCount, mesh.InstanceCount);\n        }\n        GL.bindVertexArray(null);\n    }\n    drawMesh(entityId, mesh, transform, shader, buffer, renderMode, renderCount) {\n        GL.bindVertexArray(mesh.VertexArrayBuffer);\n        const modelViewMatrix = transform.GlobalModelViewMatrix(entityId);\n        shader.SetBufferDataField('Object', 'ModelViewMatrix', modelViewMatrix, true);\n        shader.SetBufferDataField('Object', 'NormalMatrix', Matrix3.Inverse(modelViewMatrix.Matrix3));\n        shader.PushBufferData('Object');\n        if (buffer) {\n            GL.bindBuffer(GL.ELEMENT_ARRAY_BUFFER, buffer);\n            GL.drawElements(renderMode, renderCount, GL.UNSIGNED_BYTE, 0);\n        }\n        else {\n            GL.drawArrays(renderMode, 0, renderCount);\n        }\n        GL.bindVertexArray(null);\n    }\n}\n"},{"name":"ProjectRenderSystem","code":"import { GL, Matrix3, Matrix4 } from \"/@fs/../node_modules/@fwge/common/lib/index\";\nimport { AreaLight, BasicLitMaterial, Camera, DefaultWindow, DirectionalLight, InstanceMesh, Light, Material, MeshRenderer, RenderMode, Renderer, Shader, Tag, Transform } from \"/@fs/../node_modules/@fwge/core/lib/index\";\nimport { Registry, System } from \"/@fs/../node_modules/@fwge/ecs/lib/index\";\nimport { EditorTag } from \"../components/EditorTag\";\nimport { finalPassShaderFrag, finalPassShaderVert } from \"../assets/CubeShader\";\nclass ProjectRenderSystem extends System {\n    cameraView;\n    renderableView;\n    renderableShadowView;\n    areaLightView;\n    directionalLightView;\n    finalPassShader;\n    window;\n    Init() {\n        this.cameraView = Registry.RegisterView([Camera, Transform]);\n        this.renderableView = Registry.RegisterView([Material, Renderer, Transform], entity => !entity.HasComponent(EditorTag));\n        this.renderableShadowView = Registry.RegisterView([Material, Renderer, Transform], (_, material) => material.ProjectsShadows);\n        this.areaLightView = Registry.RegisterView([Light], (_, light) => light instanceof AreaLight);\n        this.directionalLightView = Registry.RegisterView([Light], (_, light) => light instanceof DirectionalLight);\n        this.finalPassShader = new Shader(finalPassShaderVert, finalPassShaderFrag);\n        this.window = new DefaultWindow();\n        // new RenderWindow({\n        //     renderPipelineMode: RenderPipelineMode.DEFERRED,\n        //     camera: Registry.GetComponent(Registry.GetView(this.cameraView)[0], Camera)!,\n        //     offset: [0,0],\n        //     scale: [1,1],\n        //     resolution: [1920,1080],\n        //     pipeline: undefined,\n        //     mainPass: new RenderPipelineStep({\n        //         name: 'MAIN_PASS',\n        //         shader: null!,\n        //         output: new RenderTarget({\n        //             colour: [ColourType.FLOAT_RGB, ColourType.FLOAT_RGB, ColourType.FLOAT_RGB],\n        //             depth: DepthType.FLOAT32,\n        //             height: 1920,\n        //             width: 1080,\n        //             clear: [0,0,0,0]\n        //         })\n        //     })\n        // })\n    }\n    Start() {\n        return;\n    }\n    Stop() {\n        return;\n    }\n    Update() {\n        GL.enable(GL.DEPTH_TEST);\n        GL.enable(GL.CULL_FACE);\n        GL.depthMask(true);\n        GL.cullFace(GL.FRONT);\n        for (var entityId of Registry.GetView(this.directionalLightView)) {\n            this.renderShadows(entityId, Registry.GetComponent(entityId, DirectionalLight));\n        }\n        GL.cullFace(GL.BACK);\n        this.renderScene(this.window);\n        GL.bindFramebuffer(GL.FRAMEBUFFER, null);\n        GL.viewport(0, 0, GL.drawingBufferWidth, GL.drawingBufferHeight);\n        GL.clearColor(0, 0, 0, 0);\n        GL.clear(GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT);\n        this.finalPassShader.Bind();\n        this.finalPassShader.SetTexture('U_Position', this.window.FinalComposite.ColourAttachments[0]);\n        this.finalPassShader.SetTexture('U_Normal', this.window.FinalComposite.ColourAttachments[1]);\n        this.finalPassShader.SetTexture('U_Albedo_Alpha', this.window.FinalComposite.ColourAttachments[2]);\n        this.finalPassShader.SetTexture('U_Depth', this.window.FinalComposite.DepthAttachment);\n        this.finalPassShader.SetTexture(`U_Dir_Tex`, Registry.GetComponent(Registry.GetView(this.directionalLightView)[0], DirectionalLight).RenderTarget.DepthAttachment);\n        let a = 0;\n        for (var entityId of Registry.GetView(this.areaLightView)) {\n            const light = Registry.GetComponent(entityId, AreaLight);\n            this.finalPassShader.SetFloatVector(`U_AreaLight[${a}].Colour`, light.Colour);\n            this.finalPassShader.SetFloat(`U_AreaLight[${a}].Intensity`, light.Intensity);\n            a++;\n        }\n        let d = 0;\n        for (var entityId of Registry.GetView(this.directionalLightView)) {\n            const light = Registry.GetComponent(entityId, DirectionalLight);\n            const transform = Registry.GetComponent(entityId, Transform);\n            const rotation = transform.GlobalRotation(entityId);\n            const rotationMatrix = Matrix4.RotationMatrix(rotation.X / 2, rotation.Y, rotation.Z);\n            const direction = Matrix4.MultiplyVector(rotationMatrix, [...DirectionalLight.DefaultDirection, 1.0]);\n            this.finalPassShader.SetFloatVector(`U_DirectionalLight[${d}].Colour`, light.Colour);\n            this.finalPassShader.SetFloat(`U_DirectionalLight[${d}].Intensity`, light.Intensity);\n            this.finalPassShader.SetFloatVector(`U_DirectionalLight[${d}].Direction`, direction.XYZ.Negate());\n            this.finalPassShader.SetBool(`U_DirectionalLight[${d}].CastShadows`, light.CastShadows);\n            this.finalPassShader.SetFloat(`U_DirectionalLight[${d}].TexelSize`, 1 / light.RenderTarget.Width);\n            this.finalPassShader.SetFloat(`U_DirectionalLight[${d}].TexelCount`, ((light.PCFLevel * 2) + 1) ** 2);\n            this.finalPassShader.SetFloat(`U_DirectionalLight[${d}].Bias`, light.Bias);\n            this.finalPassShader.SetFloat(`U_DirectionalLight[${d}].PCFLevel`, light.PCFLevel);\n            this.finalPassShader.SetMatrix(`U_DirectionalLight[${d}].ProjectionMatrix`, light.ProjectionMatrix, true);\n            this.finalPassShader.SetMatrix(`U_DirectionalLight[${d}].ViewMatrix`, rotationMatrix, true);\n            d++;\n        }\n        const cameraEntityId = Registry.GetView(this.cameraView)[0];\n        const cameraTransform = Registry.GetComponent(cameraEntityId, Transform);\n        const cameraCamera = Registry.GetComponent(cameraEntityId, Camera);\n        const cameraMV = cameraTransform.GlobalModelViewMatrix(cameraEntityId).Inverse();\n        this.finalPassShader.SetBufferDataField('Camera', 'View', cameraMV, true);\n        this.finalPassShader.SetBufferDataField('Camera', 'Projection', cameraCamera.ProjectionMatrix, true);\n        this.finalPassShader.PushBufferData('Camera');\n        GL.bindVertexArray(this.window.Panel.VertexArrayBuffer);\n        GL.bindBuffer(GL.ELEMENT_ARRAY_BUFFER, this.window.Panel.FaceBuffer);\n        GL.drawElements(GL.TRIANGLES, this.window.Panel.FaceCount, GL.UNSIGNED_BYTE, 0);\n        GL.bindVertexArray(null);\n        this.finalPassShader.UnBind();\n    }\n    renderShadows(parentId, light) {\n        light.BindForShadows(parentId);\n        for (const entityId of Registry.GetView(this.renderableView)) {\n            if (!Registry.IsEntityActive(entityId)) {\n                continue;\n            }\n            const tag = Registry.GetComponent(entityId, Tag);\n            if (tag instanceof EditorTag) {\n                continue;\n            }\n            const material = Registry.GetComponent(entityId, BasicLitMaterial);\n            if (!material.ProjectsShadows) {\n                continue;\n            }\n            const transform = Registry.GetComponent(entityId, Transform);\n            const renderer = Registry.GetComponent(entityId, MeshRenderer);\n            const mesh = renderer.Asset;\n            let renderMode;\n            let renderCount;\n            let buffer;\n            switch (renderer.RenderMode) {\n                case RenderMode.FACE:\n                    {\n                        renderMode = GL.TRIANGLES;\n                        renderCount = mesh.FaceCount;\n                        buffer = mesh.IsIndexed ? mesh.FaceBuffer : null;\n                    }\n                    break;\n                case RenderMode.EDGE:\n                    {\n                        renderMode = GL.LINES;\n                        renderCount = mesh.EdgeCount;\n                        buffer = mesh.IsIndexed ? mesh.EdgeBuffer : null;\n                    }\n                    break;\n                case RenderMode.POINT:\n                    {\n                        renderMode = GL.POINTS;\n                        renderCount = mesh.PointCount;\n                        buffer = mesh.IsIndexed ? mesh.PointBuffer : null;\n                    }\n                    break;\n            }\n            DirectionalLight.ShadowShader.SetMatrix('U_Transform.ModelView', transform.GlobalModelViewMatrix(entityId), true);\n            if (mesh instanceof InstanceMesh) {\n                this.drawInstanceMesh(entityId, mesh, transform, null, buffer, renderMode, renderCount);\n            }\n            else {\n                this.drawMesh(entityId, mesh, transform, null, buffer, renderMode, renderCount);\n            }\n        }\n        light.UnbindForShadows();\n    }\n    renderScene(window) {\n        window.MainPass.Output.Bind();\n        const cameraEntityId = Registry.GetView(this.cameraView)[0];\n        const cameraTransform = Registry.GetComponent(cameraEntityId, Transform);\n        const cameraCamera = Registry.GetComponent(cameraEntityId, Camera);\n        const cameraMV = cameraTransform.GlobalModelViewMatrix(cameraEntityId).Inverse();\n        for (const entityId of Registry.GetView(this.renderableView)) {\n            if (!Registry.IsEntityActive(entityId)) {\n                continue;\n            }\n            const tag = Registry.GetComponent(entityId, Tag);\n            if (tag instanceof EditorTag) {\n                continue;\n            }\n            const transform = Registry.GetComponent(entityId, Transform);\n            const material = Registry.GetComponent(entityId, BasicLitMaterial);\n            const renderer = Registry.GetComponent(entityId, MeshRenderer);\n            const mesh = renderer.Asset;\n            const shader = material.Shader;\n            shader.Bind();\n            shader.SetBufferDataField('Camera', 'View', cameraMV, true);\n            shader.SetBufferDataField('Camera', 'Projection', cameraCamera.ProjectionMatrix, true);\n            shader.PushBufferData('Camera');\n            material.BindBlock(shader);\n            let renderMode;\n            let renderCount;\n            let buffer;\n            switch (renderer.RenderMode) {\n                case RenderMode.FACE:\n                    {\n                        renderMode = GL.TRIANGLES;\n                        renderCount = mesh.FaceCount;\n                        buffer = mesh.IsIndexed ? mesh.FaceBuffer : null;\n                    }\n                    break;\n                case RenderMode.EDGE:\n                    {\n                        renderMode = GL.LINES;\n                        renderCount = mesh.EdgeCount;\n                        buffer = mesh.IsIndexed ? mesh.EdgeBuffer : null;\n                    }\n                    break;\n                case RenderMode.POINT:\n                    {\n                        renderMode = GL.POINTS;\n                        renderCount = mesh.PointCount;\n                        buffer = mesh.IsIndexed ? mesh.PointBuffer : null;\n                    }\n                    break;\n            }\n            if (mesh instanceof InstanceMesh) {\n                this.drawInstanceMesh(entityId, mesh, transform, shader, buffer, renderMode, renderCount);\n            }\n            else {\n                this.drawMesh(entityId, mesh, transform, shader, buffer, renderMode, renderCount);\n            }\n            shader.UnBind();\n        }\n    }\n    drawInstanceMesh(entityId, mesh, transform, shader, buffer, renderMode, renderCount) {\n        GL.bindVertexArray(mesh.VertexArrayBuffer);\n        const modelViewMatrix = transform.GlobalModelViewMatrix(entityId);\n        shader?.SetBufferDataField('Transform', 'Model', modelViewMatrix, true);\n        shader?.SetBufferDataField('Transform', 'Normal', Matrix3.Inverse(modelViewMatrix.Matrix3));\n        shader?.PushBufferData('Transform');\n        if (buffer) {\n            GL.bindBuffer(GL.ELEMENT_ARRAY_BUFFER, buffer);\n            GL.drawElementsInstanced(renderMode, renderCount, GL.UNSIGNED_BYTE, 0, mesh.InstanceCount);\n        }\n        else {\n            GL.drawArraysInstanced(renderMode, 0, renderCount, mesh.InstanceCount);\n        }\n        GL.bindVertexArray(null);\n    }\n    drawMesh(entityId, mesh, transform, shader, buffer, renderMode, renderCount) {\n        GL.bindVertexArray(mesh.VertexArrayBuffer);\n        const modelViewMatrix = transform.GlobalModelViewMatrix(entityId);\n        shader?.SetBufferDataField('Transform', 'Model', modelViewMatrix, true);\n        shader?.SetBufferDataField('Transform', 'Normal', Matrix3.Inverse(modelViewMatrix.Matrix3));\n        shader?.PushBufferData('Transform');\n        if (buffer) {\n            GL.bindBuffer(GL.ELEMENT_ARRAY_BUFFER, buffer);\n            GL.drawElements(renderMode, renderCount, GL.UNSIGNED_BYTE, 0);\n        }\n        else {\n            GL.drawArrays(renderMode, 0, renderCount);\n        }\n        GL.bindVertexArray(null);\n    }\n}\n"}]